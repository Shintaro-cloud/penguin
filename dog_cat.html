const IMG_SIZE = 50;
let model;

async function loadModel() {
  try {
    model = await tf.loadLayersModel('tfjs_model/model.json');
    console.log('ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†:', model);
  } catch (e) {
    console.error('ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å¤±æ•—:', e);
  }
}

function preprocessImage(image) {
  console.log('ç”»åƒã‚’å‰å‡¦ç†ä¸­...');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  ctx.drawImage(image, 0, 0, IMG_SIZE, IMG_SIZE);
  const imageData = ctx.getImageData(0, 0, IMG_SIZE, IMG_SIZE);
  const tensor = tf.browser.fromPixels(imageData).toFloat().div(255).expandDims(0);
  console.log('ãƒ†ãƒ³ã‚½ãƒ«å½¢çŠ¶:', tensor.shape);
  return tensor;
}

document.getElementById('imageInput').addEventListener('change', (event) => {
  const file = event.target.files[0];
  if (!file) {
    console.log('ãƒ•ã‚¡ã‚¤ãƒ«ãŒé¸æŠã•ã‚Œã¦ã„ã¾ã›ã‚“');
    return;
  }
  console.log('ãƒ•ã‚¡ã‚¤ãƒ«é¸æŠ:', file.name);

  const img = new Image();
  img.onload = async () => {
    console.log('ç”»åƒãŒèª­ã¿è¾¼ã¾ã‚Œã¾ã—ãŸ');
    try {
      const inputTensor = preprocessImage(img);
      const prediction = await model.predict(inputTensor).data();
      console.log('äºˆæ¸¬çµæœ:', prediction);
      const dogProb = prediction[0];
      const catProb = prediction[1];
      const resultText = dogProb > catProb ? 'ğŸ¶ çŠ¬ã¨åˆ¤å®šã•ã‚Œã¾ã—ãŸ' : 'ğŸ± çŒ«ã¨åˆ¤å®šã•ã‚Œã¾ã—ãŸ';
      document.getElementById('result').innerText = `${resultText}ï¼ˆçŠ¬: ${(dogProb*100).toFixed(1)}%ã€çŒ«: ${(catProb*100).toFixed(1)}%ï¼‰`;
    } catch (e) {
      console.error('äºˆæ¸¬å‡¦ç†ã§ã‚¨ãƒ©ãƒ¼:', e);
      document.getElementById('result').innerText = 'åˆ¤å®šä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚';
    }
  };
  img.onerror = () => {
    console.error('ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
    document.getElementById('result').innerText = 'ç”»åƒã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚';
  };
  img.src = URL.createObjectURL(file);
});

loadModel();

